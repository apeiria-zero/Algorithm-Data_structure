# bin_sort

Date Created: Aug 16, 2020 12:05 PM
Status: sort

**ビンソートの性質**

データの個数をｎ、用意したビンの個数をｍとする。

ｎ個のデータをビンに振り分けるにはO(n)の手間がかかる。

また、データをビンから振り分けるにはすべてのビンをチェックしなくてはいけないのでO(m)の手間がかかる。したがって、これらを合計したO(m+n)がビンソートの計算量である。

用意したビンの個数ｍがデータの個数ｎに比べて極端に大きくなければ計算量はビンソートに必要な計算量はO(n)とみなすことができる。しかし、ビンの個数が極端に多い場合はO(m)となる。このようなケースでは挿入ソートなどのほうが高速。

また、作業用にｍ個のビンを使うということは、O(m)の作業領域が必要になる。ｍがｎと比較して極端に大きくないと仮定すれば要素の個数ｎに比例する作業用領域が必要になるつまりビンソートの領域計算量はO(n)ということになる。

ビンソートは計算量がO(n) と高速な反面、データの量に比例する作業用領域が必要になる。

**ビンソートの弱点**

・キーの重複が許されない

・キーのとる値はある範囲に収まる整数でなければならない

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct {
    int key; //keyが-1の時、binは空
    int other; //その他情報
}DATA;

#define M 100 //keyの上限

DATA bin[M+1];

void bin_sort(DATA a[],int n){
    int i,j;
    //binを空にする
    for (i = 0;  i<=M ; ++i) {
        bin[i].key=-1;
    }
    //配列aのデータをビンに振り分ける
    for (i = 0;  i<n ; ++i) {
        bin[a[i].key]=a[i];
    }
    j=0;
    //データをbinから昇順に取り出して、配列aに戻す
    for (i = 0;  i<=M ; ++i) {
        if(bin[i].key!=-1)
            a[j++]=bin[i];
    }
}

void main(void){
    DATA a[3]=
            {
                    {4,NULL},
                    {3,NULL},
                    {1,NULL},
            };
    bin_sort(a,3);
    for (int i = 0; i <3 ; ++i) {
        printf("%d ",a[i].key);
    }
}
```