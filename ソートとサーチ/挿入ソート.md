# 挿入ソート

Created: Apr 10, 2020 10:17 PM
Property: ape iria
Tags: sort

配列のうち一部分を整列済の状態にしておき、残りの要素を１つずつその中の適切な位置に挿入していくというのが挿入ソートの原理です。

**※挿入ソートの計算量について**

まず外側のループがn-1回実行されるのは明らかです。

内側のループが実行される回数は与えられる配列の並びに依存します。

しかし平均すると内側のループはi/2回くらい繰り返されますから、内側の計算量はO(n)です。

ですから全体の計算量はO(n^2)となります。

しかし、要素の位置を変えずに挿入される場合は内側のループは１回も実行されません。

したがって、ほとんどの要素がすでに整列済の配列に対して挿入ソートを適用すれば、内側のループの計算量はO(1)で収まることになり、全体の計算量はO(n)となります。

挿入ソートのアルゴリズムは「**より整列されたデータを好む**」という性質があります。

これはシェルソートを理解する上で重要な性質となるので覚えておいてください。

    #include <stdio.h>
    #include <stdlib.h>
    
    #define N 100
    
    void main(void){
        int a[N],t;
        for (int i = 0; i <N; ++i)
            a[i]=rand();
        for (int i = 1; i <N; ++i) {
            for (int j = i-1; j >=0; j--) {
                if(a[j]>a[j+1]){
                    t=a[j];a[j]=a[j+1];a[j+1]=t;
                }
                else
    		        　　break;　
            }
        }
        for (int i = 0; i <N ; ++i) {
            printf("%8d",a[i]);
        }
    }

ここで注意したいのが、break文を使っていることです。

要素の入れ替えをしない→a[ j ]<a[ j + 1]が成り立っているので、a[ j ] より左側はアクセスしなくても良いです。a[ j ]より先頭の配列は正しくソートされているので、何度もアクセスするのはとても効率が悪いです。break文を使わなくてもプログラムは動きますが、計算量を意識していきたいものですね。（計算量はどちらもO(n²)ですが、実際はbreak文を使うほうが圧倒的に高速です。）

**実行結果（乱数を使用しているので環境によって異なります。）**

    41 153 288 292 491 778 1842 1869 2082 2995 3035 3548 3902 4664 4827
    4966 5436 5447 5537 5705 6334 6729 6868 7376 7711 8723 8942 9040 9741 9894
    9961 11323 11478 11538 11840 11942 12316 12382 12623 12859 13931 14604 14771 15006 15141
    15350 15724 15890 16118 16541 16827 16944 17035 17421 17673 18467 18716 18756 19169 19264
    19629 19718 19895 19912 19954 20037 21538 21726 22190 22648 22929 23281 23805 23811 24084
    24370 24393 24464 24626 25547 25667 26299 26308 26500 26962 27446 27529 27644 28145 28253
    28703 29358 30106 30333 31101 31322 32391 32439 32662 32757