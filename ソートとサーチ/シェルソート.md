# シェルソート

Created: Apr 10, 2020 2:20 PM
Property: ape iria
Tags: sort

挿入ソートが行われる前に、前処理として最初は遠く離れた要素を整列の対象として、そのうちにだんだんと近い要素を整列し、最終的に隣り合った要素を整列する。

hずつ離れた要素を整列させることを **h-ソート(h-sort)**と呼ぶら。

また、hずつ離れた要素が整列されている配列を「**h-sort済み(h-sorted)**である」という。

下記の例では、はじめに50ずつ離れた要素を整列したので、50-ソートを行ったことになる。

この時点でデータの組は(x,y)のような５０個の組になっている。

次に25-ソートが行われ、(x,y,z,w)のような25個の組になる。

この操作を繰り返し行うことで最終的に1-ソートとなる。（h=1のときが挿入ソート）

**※シェルソートの計算量**

本来なら1回ソートを行うだけで済むのにそのまえにh-sort(h>1)と何回も余分な作業をしているからかえって手間がかかるのではという疑問が持ち上がると思いますが

挿入ソートは**より整列されたデータを好む**性質があります。

シェルソートの数学的な解析は難しいので、直感的な説明でとどめておきます。

挿入ソートとシェルソートの計算量を比較します。

はじめの50-ソートでは50組の要素が対象になりますが、各組は２つの要素を持っているに過ぎません。要素がランダムに並んでいるときの計算量は要素の個数の２乗に比例します。しかしはじめのうちは整列の対象となる要素が少ないのであまり手間がかからずにh-ソートができるはずです。

たとえば、10000この要素を持った配列の5000-ソートを考えると、これは2つの要素からなる5000組のデータを整列することになります。2つの要素からなる並びを整列するには、要素の個数をi(=2)として、

O（i^2）

の計算量が必要です。また、これが5000組あるわけですから、5000-ソートを行うための計算量は

全体の配列要素数をnとして、

n/2 x O(i^2)=O(n) x O(i^2)=O(n)

となります。（nはi^2よりも十分に大きいので定数項とみなします。）

これは1-ソート(普通の挿入ソート)を行うための計算量（O(n^2)）よりずっと小さいですよね。

また、h-ソートに関しては次のような性質があります。

xとyが整数でx>yとすると、x-ソートを行ったあとにy-ソートを行うと、その結果はx-ソート済み、y-ソート済みの両方の性質を満たす。

ここで、xとyは倍数の関係になくても構わないのがポイントです。

したがって、この性質から、シェルソートは減少する数列に従ってh-ソートを行う手順であることができます。

また、数列に現れる値は、互いに倍数になっていないほうが良い結果が得られます。

    #include <stdio.h>
    #include <stdlib.h>
    
    #define N 100
    
    int main() {
        int a[N],gap,t;
    
        for (int i = 0; i <N ; ++i)
            a[i]=rand();
    
        gap=N/2;
        while(gap>0){
            for (int k = 0; k <gap ; ++k) {
                for (int i = k+gap; i <N ; ++i) {
                    for (int j = i-gap; j >=k ; j=j-gap) {
                        if(a[j]>a[j+gap]){
                            t=a[j];a[j]=a[j+gap];a[j+gap]=t;
                        }
                        else
                            break;
                    }
                }
            }
            gap=gap/2;
        }
        for (int i = 0; i <N ; ++i) {
            printf("%8d",a[i]);
        }
    }

実行結果(乱数を使っているため、環境によって異なります。)

    41 153 288 292 491 778 1842 1869 2082 2995 3035 3548 3902 4664 4827
    4966 5436 5447 5537 5705 6334 6729 6868 7376 7711 8723 8942 9040 9741 9894
    9961 11323 11478 11538 11840 11942 12316 12382 12623 12859 13931 14604 14771 15006 15141
    15350 15724 15890 16118 16541 16827 16944 17035 17421 17673 18467 18716 18756 19169 19264
    19629 19718 19895 19912 19954 20037 21538 21726 22190 22648 22929 23281 23805 23811 24084
    24370 24393 24464 24626 25547 25667 26299 26308 26500 26962 27446 27529 27644 28145 28253
    28703 29358 30106 30333 31101 31322 32391 32439 32662 32757

**※参考　番兵を用いる場合**

    #include <stdio.h>
    #include <stdlib.h>
    
    #define N 100 //データ数
    
    void main(){
        int a[N+1],t,j,i;
    
        for (int i = 1;i<=N;++i) {
            a[i]=rand();
        }
    	  a[0]=-9999; 　　　　　　　　　//番兵
        for (i = 2; i <=N; ++i) {
    				t=a[i];                 
            for (j = i-1;t<a[j]; j--) //配列を昇順にソート(t<a[j])の部分
                a[j+1]=a[j];
            a[j+1]=t;      //配列要素の入れ替え
        }
        for (i = 1; i <=N; ++i) {
            printf("%8d",a[i]);
        }
        printf("\n");
    }

配列を昇順する際、a[0]が-9999となっているので、ループ脱出が必ずできる。

下界を設定するイメージ。